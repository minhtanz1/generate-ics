<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Scheduler v2 // Leitner & Interleaving</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-color: #252526;
            --input-bg: #3c3c3c;
            --text-color: #d4d4d4;
            --accent-color: #007acc;
            --review-color: #c586c0; /* Pink for reviews */
            --work-color: #4ec9b0;   /* Green for work */
            --border-color: #444;
            --font-mono: 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-mono);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            font-size: 13px;
        }

        h1, h3 { margin: 0 0 10px 0; font-weight: normal; color: var(--work-color); }
        .badge-rev { color: var(--review-color); font-weight: bold; }
        
        .container {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            height: 90vh;
        }

        .panel {
            background-color: var(--panel-color);
            border: 1px solid var(--border-color);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
        }

        .form-group { display: flex; flex-direction: column; gap: 5px; }
        .checkbox-group { display: flex; align-items: center; gap: 10px; margin-top:5px; }
        
        label { font-size: 11px; opacity: 0.7; text-transform: uppercase; letter-spacing: 0.5px;}

        input[type="text"], input[type="number"], input[type="datetime-local"], button {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 8px;
            font-family: var(--font-mono);
            outline: none;
        }

        button { cursor: pointer; transition: background 0.2s; font-weight: bold; }
        button:hover { background-color: #505050; }
        button.primary { background-color: var(--accent-color); color: white; border: none; }
        
        .task-list { border-top: 1px solid var(--border-color); margin-top: 10px; padding-top: 10px; display: flex; flex-direction: column; gap: 8px; }
        .task-item { display: grid; grid-template-columns: 1fr 50px 30px; gap: 5px; align-items: center; }

        .preview-area {
            background-color: #111;
            padding: 10px;
            border: 1px solid var(--border-color);
            white-space: pre-wrap;
            overflow-y: auto;
            flex-grow: 1;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .log-entry { border-bottom: 1px dashed #333; padding: 2px 0; display: flex;}
        .col-time { width: 140px; color: #569cd6; flex-shrink: 0;}
        .col-type { width: 80px; text-align: center; margin-right: 10px; border-radius: 2px; font-size: 11px; padding: 1px;}
        .type-work { background: #0e3a3e; color: #4ec9b0; border: 1px solid #1a5c63; }
        .type-review { background: #3a1d36; color: #c586c0; border: 1px solid #632d5a; }
        .col-msg { color: #d4d4d4; }

    </style>
</head>
<body>

    <h1>// SCHEDULER: LEITNER & INTERLEAVING MODE</h1>

    <div class="container">
        <!-- LEFT PANEL -->
        <div class="panel">
            <h3>1. GLOBAL CONFIG</h3>
            <div class="form-group">
                <label>Start / End Date</label>
                <input type="datetime-local" id="globalStart">
                <input type="datetime-local" id="globalEnd" style="margin-top:5px">
            </div>
            
            <div class="form-group">
                <label>Deep Work Config (Minutes)</label>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px">
                    <input type="number" id="chunkSize" value="45" title="Work Chunk Duration">
                    <input type="number" id="reviewSize" value="15" title="Review Chunk Duration">
                </div>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="useInterleaving" checked>
                <label for="useInterleaving" style="color:white; opacity:1">Enable Interleaving (Shuffle)</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="useLeitner" checked>
                <label for="useLeitner" style="color:var(--review-color); opacity:1">Enable Leitner Review</label>
            </div>

            <hr style="width:100%; border:0; border-top:1px solid var(--border-color);">

            <h3>2. TASKS & PRIORITY</h3>
            <div class="task-list" id="taskList"></div>
            <button onclick="UI.addTaskRow()">+ Add Task</button>

            <hr style="width:100%; border:0; border-top:1px solid var(--border-color);">
            
            <button class="primary" onclick="App.generate()">>> GENERATE SMART SCHEDULE</button>
            <button onclick="App.downloadICS()">Download .ICS</button>
        </div>

        <!-- RIGHT PANEL -->
        <div class="panel">
            <h3>3. SYSTEM LOG / PREVIEW</h3>
            <div id="previewConsole" class="preview-area">
                // System ready.
                // Interleaving Mode: Enabled
                // Leitner Review: Enabled
            </div>
        </div>
    </div>

<script>
/**
 * ==========================================
 * CONFIG & CORE
 * ==========================================
 */
const CONFIG = {
    blockedHours: [
        { start: 23, end: 7 }, // Ng·ªß
        { start: 12, end: 13 }, // ƒÇn tr∆∞a
        { start: 18, end: 19 }  // ƒÇn t·ªëi
    ],
    bufferMinutes: 5 // Th·ªùi gian ngh·ªâ nh·ªè gi·ªØa c√°c chunk ƒë·ªÉ chuy·ªÉn context
};

/**
 * ==========================================
 * MODULE: TIME ENGINE
 * ==========================================
 */
class TimeManager {
    constructor() { this.blockedRanges = CONFIG.blockedHours; }

    isBlocked(date) {
        const h = date.getHours();
        for (let b of this.blockedRanges) {
            if (b.start > b.end) { if (h >= b.start || h < b.end) return true; }
            else { if (h >= b.start && h < b.end) return true; }
        }
        return false;
    }

    getNextValidTime(date) {
        let d = new Date(date);
        while (this.isBlocked(d)) d.setMinutes(d.getMinutes() + 1);
        return d;
    }

    // T√≠nh to√°n th·ªùi gian kh·∫£ d·ª•ng th·ª±c t·∫ø
    calculateAvailableMinutes(start, end) {
        let total = 0;
        let cur = new Date(start);
        const e = new Date(end);
        while (cur < e) {
            if (!this.isBlocked(cur)) total++;
            cur.setMinutes(cur.getMinutes() + 1);
        }
        return total;
    }
}

/**
 * ==========================================
 * MODULE: SMART SCHEDULER (ALGORITHM)
 * ==========================================
 */
class SmartScheduler {
    constructor() {
        this.tm = new TimeManager();
    }

    process(tasks, startStr, endStr, options) {
        const startDate = new Date(startStr);
        const endDate = new Date(endStr);
        const { chunkSize, reviewSize, interleaving, leitner } = options;

        // 1. Validate & Prep
        const availableMins = this.tm.calculateAvailableMinutes(startDate, endDate);
        const totalWeight = tasks.reduce((sum, t) => sum + t.weight, 0);
        if (availableMins <= 0 || totalWeight === 0) throw new Error("Invalid time range or weights.");

        // 2. Chuy·ªÉn ƒë·ªïi Weight th√†nh Block (Chunks)
        // Ch√∫ng ta d√†nh 80% th·ªùi gian cho Work, 20% d·ª± ph√≤ng cho Review (n·∫øu Leitner b·∫≠t)
        const workableRatio = leitner ? 0.85 : 1.0; 
        const usableMinutes = availableMins * workableRatio;

        let taskQueues = {}; // L∆∞u danh s√°ch chunk cho t·ª´ng task

        tasks.forEach(task => {
            const ratio = task.weight / totalWeight;
            const taskTotalMins = Math.floor(usableMinutes * ratio);
            
            // S·ªë l∆∞·ª£ng chunk l√†m vi·ªác ch√≠nh
            let workCount = Math.floor(taskTotalMins / chunkSize);
            if (workCount < 1) workCount = 1; // T·ªëi thi·ªÉu 1 chunk

            taskQueues[task.name] = [];

            // T·∫°o Work Chunks
            for (let i = 0; i < workCount; i++) {
                taskQueues[task.name].push({
                    type: 'WORK',
                    title: task.name,
                    duration: chunkSize,
                    desc: `Deep Work Session (${i+1}/${workCount})`
                });
            }

            // T·∫°o Review Chunks (Leitner Strategy)
            // Logic: C·ª© 3 work chunk th√¨ th√™m 1 review chunk. Ho·∫∑c t·ªëi thi·ªÉu 1 review n·∫øu tr·ªçng s·ªë cao.
            if (leitner) {
                const reviewCount = Math.max(1, Math.floor(workCount / 3)); 
                for (let j = 0; j < reviewCount; j++) {
                    taskQueues[task.name].push({
                        type: 'REVIEW',
                        title: `Review: ${task.name}`,
                        duration: reviewSize,
                        desc: `Spaced Repetition Review`
                    });
                }
            }
        });

        // 3. Queue Merging & Interleaving Strategy
        let finalQueue = [];

        if (interleaving) {
            // Round Robin: L·∫•y l·∫ßn l∆∞·ª£t t·ª´ng task b·ªè v√†o h√†ng ƒë·ª£i chung
            // A1, B1, C1, A2, B2... -> Gi√∫p n√£o ƒë·ªïi context li√™n t·ª•c
            const names = Object.keys(taskQueues);
            let maxLen = Math.max(...names.map(n => taskQueues[n].length));

            for (let i = 0; i < maxLen; i++) {
                names.forEach(name => {
                    if (taskQueues[name][i]) {
                        finalQueue.push(taskQueues[name][i]);
                    }
                });
            }
        } else {
            // Blocked: L√†m h·∫øt A r·ªìi ƒë·∫øn h·∫øt B
            for (let name in taskQueues) {
                finalQueue = finalQueue.concat(taskQueues[name]);
            }
        }

        // 4. Time Mapping (G√°n th·ªùi gian th·ª±c cho Queue)
        let schedule = [];
        let cursor = this.tm.getNextValidTime(startDate);

        finalQueue.forEach(item => {
            if (cursor >= endDate) return; // H·∫øt gi·ªù

            // T√¨m slot tr·ªëng cho chunk n√†y
            let slotStart = new Date(cursor);
            let slotEnd = new Date(cursor);
            let needed = item.duration;

            // Ki·ªÉm tra xem duration n√†y c√≥ b·ªã d√≠nh v√†o gi·ªù ch·∫∑n kh√¥ng
            // ƒê·ªÉ ƒë∆°n gi·∫£n cho admin dashboard: N·∫øu d√≠nh gi·ªù ch·∫∑n, ƒë·∫©y h·∫≥n sang sau gi·ªù ch·∫∑n
            // (Kh√¥ng chia c·∫Øt 1 chunk 45p th√†nh 2 m·∫£nh nh·ªè, v√¨ Deep Work c·∫ßn li·ªÅn m·∫°ch)
            
            let fits = false;
            while(!fits && slotStart < endDate) {
                // Gi·∫£ l·∫≠p c·ªông th·ªùi gian
                let tempCursor = new Date(slotStart);
                let validMinsFound = 0;
                let isInterrupted = false;

                for(let m=0; m<needed; m++) {
                    if(this.tm.isBlocked(tempCursor)) {
                        isInterrupted = true;
                        break;
                    }
                    tempCursor.setMinutes(tempCursor.getMinutes() + 1);
                }

                if(!isInterrupted) {
                    slotEnd = tempCursor;
                    fits = true;
                } else {
                    // N·∫øu b·ªã ch·∫∑n, nh·∫£y cursor t·ªõi v√πng valid ti·∫øp theo
                    slotStart = this.tm.getNextValidTime(tempCursor);
                }
            }

            if (fits && slotEnd <= endDate) {
                schedule.push({
                    title: item.title,
                    type: item.type,
                    start: new Date(slotStart),
                    end: new Date(slotEnd),
                    description: item.desc
                });

                // C·∫≠p nh·∫≠t cursor th·∫≠t + buffer
                cursor = new Date(slotEnd);
                cursor.setMinutes(cursor.getMinutes() + CONFIG.bufferMinutes);
                cursor = this.tm.getNextValidTime(cursor);
            }
        });

        return schedule;
    }
}

/**
 * ==========================================
 * MODULE: ICS GEN
 * ==========================================
 */
class ICSGenerator {
    static generate(events) {
        let c = "BEGIN:VCALENDAR\r\nVERSION:2.0\r\nPRODID:-//CoderLo//LeitnerSched//EN\r\n";
        events.forEach(e => {
            c += "BEGIN:VEVENT\r\n";
            c += `DTSTART:${this.fmt(e.start)}\r\nDTEND:${this.fmt(e.end)}\r\n`;
            c += `SUMMARY:${e.type === 'REVIEW' ? 'üîÑ ' : '‚ö° '}${e.title}\r\n`;
            c += `DESCRIPTION:${e.description}\r\nEND:VEVENT\r\n`;
        });
        c += "END:VCALENDAR";
        return c;
    }
    static fmt(d) {
        const p = n => n < 10 ? '0' + n : n;
        return d.getFullYear()+p(d.getMonth()+1)+p(d.getDate())+'T'+p(d.getHours())+p(d.getMinutes())+'00';
    }
}

/**
 * ==========================================
 * UI CONTROLLER
 * ==========================================
 */
const UI = {
    init() {
        const now = new Date();
        const nextW = new Date(now); nextW.setDate(nextW.getDate() + 5);
        document.getElementById('globalStart').value = now.toISOString().slice(0, 16);
        document.getElementById('globalEnd').value = nextW.toISOString().slice(0, 16);
        this.addTaskRow("Learn React Hooks", 20);
        this.addTaskRow("System Design", 10);
        this.addTaskRow("Gym / Workout", 15);
    },

    addTaskRow(n="", w="") {
        const d = document.createElement('div'); d.className = 'task-item';
        d.innerHTML = `<input type="text" class="t-name" value="${n}" placeholder="Task Name">
                       <input type="number" class="t-weight" value="${w}" placeholder="W">
                       <button class="delete-btn" onclick="this.parentElement.remove()" style="background:#ce4646;color:white;border:none">x</button>`;
        document.getElementById('taskList').appendChild(d);
    },

    getTasks() {
        return Array.from(document.querySelectorAll('.task-item')).map(r => ({
            name: r.querySelector('.t-name').value,
            weight: parseInt(r.querySelector('.t-weight').value || 1)
        })).filter(t => t.name);
    },

    log(evt) {
        const consoleDiv = document.getElementById('previewConsole');
        const d = document.createElement('div');
        d.className = 'log-entry';
        
        const timeStr = `${evt.start.getDate()}/${evt.start.getMonth()+1} [${evt.start.getHours()}:${(evt.start.getMinutes()<10?'0':'')+evt.start.getMinutes()}]`;
        const typeClass = evt.type === 'WORK' ? 'type-work' : 'type-review';
        
        d.innerHTML = `<div class="col-time">${timeStr}</div>
                       <div class="col-type ${typeClass}">${evt.type}</div>
                       <div class="col-msg">${evt.title}</div>`;
        consoleDiv.appendChild(d);
        consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }
};

/**
 * ==========================================
 * APP MAIN
 * ==========================================
 */
const App = {
    events: [],
    
    generate() {
        const con = document.getElementById('previewConsole');
        con.innerHTML = ''; 
        
        const tasks = UI.getTasks();
        const start = document.getElementById('globalStart').value;
        const end = document.getElementById('globalEnd').value;
        const opts = {
            chunkSize: parseInt(document.getElementById('chunkSize').value),
            reviewSize: parseInt(document.getElementById('reviewSize').value),
            interleaving: document.getElementById('useInterleaving').checked,
            leitner: document.getElementById('useLeitner').checked
        };

        try {
            const scheduler = new SmartScheduler();
            this.events = scheduler.process(tasks, start, end, opts);

            // Log Stats
            const d = document.createElement('div');
            d.style.color = '#888'; d.style.borderBottom = '1px solid #333'; d.style.marginBottom='10px';
            d.innerText = `// Generated ${this.events.length} blocks. Interleaving: ${opts.interleaving}, Leitner: ${opts.leitner}`;
            con.appendChild(d);

            this.events.forEach(UI.log);
            
        } catch(e) {
            con.innerText = `[ERROR] ${e.message}`;
        }
    },

    downloadICS() {
        if(!this.events.length) return alert("Generate first!");
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([ICSGenerator.generate(this.events)], {type:'text/calendar'}));
        a.download = 'smart_schedule.ics';
        a.click();
    }
};

UI.init();
</script>
</body>
</html>

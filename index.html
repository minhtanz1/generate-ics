<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Scheduler v2.1 // Custom Descriptions</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-color: #252526;
            --input-bg: #3c3c3c;
            --text-color: #d4d4d4;
            --accent-color: #007acc;
            --review-color: #c586c0; 
            --work-color: #4ec9b0;   
            --border-color: #444;
            --font-mono: 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-mono);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            font-size: 13px;
        }

        h1, h3 { margin: 0 0 10px 0; font-weight: normal; color: var(--work-color); }
        
        .container {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            height: 90vh;
        }

        .panel {
            background-color: var(--panel-color);
            border: 1px solid var(--border-color);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
        }

        .form-group { display: flex; flex-direction: column; gap: 5px; }
        .checkbox-group { display: flex; align-items: center; gap: 10px; margin-top:5px; }
        
        label { font-size: 11px; opacity: 0.7; text-transform: uppercase; letter-spacing: 0.5px;}

        input[type="text"], input[type="number"], input[type="datetime-local"], button {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 8px;
            font-family: var(--font-mono);
            outline: none;
        }

        button { cursor: pointer; transition: background 0.2s; font-weight: bold; }
        button:hover { background-color: #505050; }
        button.primary { background-color: var(--accent-color); color: white; border: none; }
        
        .task-list { border-top: 1px solid var(--border-color); margin-top: 10px; padding-top: 10px; display: flex; flex-direction: column; gap: 8px; }
        .task-item { display: grid; grid-template-columns: 1fr 50px 30px; gap: 5px; align-items: center; }

        .preview-area {
            background-color: #111;
            padding: 10px;
            border: 1px solid var(--border-color);
            white-space: pre-wrap;
            overflow-y: auto;
            flex-grow: 1;
            font-size: 12px;
            line-height: 1.4;
        }
        
        /* LOG STYLES */
        .log-container { display: flex; flex-direction: column; border-bottom: 1px dashed #333; padding: 4px 0; }
        .log-row { display: flex; align-items: center; }
        .col-time { width: 130px; color: #569cd6; flex-shrink: 0;}
        .col-type { width: 70px; text-align: center; margin-right: 10px; border-radius: 2px; font-size: 10px; padding: 1px;}
        .type-work { background: #0e3a3e; color: #4ec9b0; border: 1px solid #1a5c63; }
        .type-review { background: #3a1d36; color: #c586c0; border: 1px solid #632d5a; }
        .col-msg { color: #d4d4d4; flex-grow: 1; }
        
        .btn-edit-desc {
            background: none; border: none; color: #666; font-size: 11px; padding: 2px 5px; margin-left: 10px;
        }
        .btn-edit-desc:hover { color: var(--accent-color); background: #222; }

        .desc-input-wrapper {
            display: none; /* Hidden by default */
            margin-left: 140px; /* Align with text */
            margin-top: 4px;
            margin-bottom: 4px;
        }
        .desc-input {
            width: 90%;
            background-color: #222;
            border: 1px solid #444;
            color: #ce9178; /* String color */
            font-size: 11px;
            padding: 4px;
        }
        .desc-input::placeholder { color: #555; font-style: italic; }

    </style>
</head>
<body>

    <h1>// SCHEDULER: LEITNER & INTERLEAVING MODE</h1>

    <div class="container">
        <!-- LEFT PANEL -->
        <div class="panel">
            <h3>1. GLOBAL CONFIG</h3>
            <div class="form-group">
                <label>Start / End Date</label>
                <input type="datetime-local" id="globalStart">
                <input type="datetime-local" id="globalEnd" style="margin-top:5px">
            </div>
            
            <div class="form-group">
                <label>Deep Work Config (Minutes)</label>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px">
                    <input type="number" id="chunkSize" value="45" title="Work Chunk Duration">
                    <input type="number" id="reviewSize" value="15" title="Review Chunk Duration">
                </div>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="useInterleaving" checked>
                <label for="useInterleaving" style="color:white; opacity:1">Enable Interleaving (Shuffle)</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="useLeitner" checked>
                <label for="useLeitner" style="color:var(--review-color); opacity:1">Enable Leitner Review</label>
            </div>

            <hr style="width:100%; border:0; border-top:1px solid var(--border-color);">

            <h3>2. TASKS & PRIORITY</h3>
            <div class="task-list" id="taskList"></div>
            <button onclick="UI.addTaskRow()">+ Add Task</button>

            <hr style="width:100%; border:0; border-top:1px solid var(--border-color);">
            
            <button class="primary" onclick="App.generate()">>> GENERATE SCHEDULE</button>
            <button onclick="App.downloadICS()">Download .ICS</button>
        </div>

        <!-- RIGHT PANEL -->
        <div class="panel">
            <h3>3. PREVIEW & CUSTOMIZE</h3>
            <div id="previewConsole" class="preview-area">
                // 1. Add Tasks on the left.
                // 2. Click Generate.
                // 3. Click [âœŽ Note] to add custom description if needed.
                // 4. Download ICS.
            </div>
        </div>
    </div>

<script>
/* ================= CORE CONFIG ================= */
const CONFIG = {
    blockedHours: [
        { start: 23, end: 7 }, // Ngá»§
        { start: 12, end: 13 }, // Ä‚n trÆ°a
        { start: 18, end: 19 }  // Ä‚n tá»‘i
    ],
    bufferMinutes: 5 
};

/* ================= TIME ENGINE ================= */
class TimeManager {
    constructor() { this.blockedRanges = CONFIG.blockedHours; }
    isBlocked(date) {
        const h = date.getHours();
        for (let b of this.blockedRanges) {
            if (b.start > b.end) { if (h >= b.start || h < b.end) return true; }
            else { if (h >= b.start && h < b.end) return true; }
        }
        return false;
    }
    getNextValidTime(date) {
        let d = new Date(date);
        while (this.isBlocked(d)) d.setMinutes(d.getMinutes() + 1);
        return d;
    }
    calculateAvailableMinutes(start, end) {
        let total = 0;
        let cur = new Date(start);
        const e = new Date(end);
        while (cur < e) {
            if (!this.isBlocked(cur)) total++;
            cur.setMinutes(cur.getMinutes() + 1);
        }
        return total;
    }
}

/* ================= SMART SCHEDULER ================= */
class SmartScheduler {
    constructor() { this.tm = new TimeManager(); }
    process(tasks, startStr, endStr, options) {
        const startDate = new Date(startStr);
        const endDate = new Date(endStr);
        const { chunkSize, reviewSize, interleaving, leitner } = options;

        const availableMins = this.tm.calculateAvailableMinutes(startDate, endDate);
        const totalWeight = tasks.reduce((sum, t) => sum + t.weight, 0);
        if (availableMins <= 0 || totalWeight === 0) throw new Error("Invalid time range or weights.");

        const workableRatio = leitner ? 0.85 : 1.0; 
        const usableMinutes = availableMins * workableRatio;

        let taskQueues = {}; 

        tasks.forEach(task => {
            const ratio = task.weight / totalWeight;
            const taskTotalMins = Math.floor(usableMinutes * ratio);
            let workCount = Math.max(1, Math.floor(taskTotalMins / chunkSize));

            taskQueues[task.name] = [];
            for (let i = 0; i < workCount; i++) {
                taskQueues[task.name].push({
                    type: 'WORK',
                    title: task.name,
                    duration: chunkSize,
                    desc: `Deep Work Session (${i+1}/${workCount})`,
                    customNote: '' // Init empty custom note
                });
            }

            if (leitner) {
                const reviewCount = Math.max(1, Math.floor(workCount / 3)); 
                for (let j = 0; j < reviewCount; j++) {
                    taskQueues[task.name].push({
                        type: 'REVIEW',
                        title: `Review: ${task.name}`,
                        duration: reviewSize,
                        desc: `Spaced Repetition Review`,
                        customNote: ''
                    });
                }
            }
        });

        let finalQueue = [];
        if (interleaving) {
            const names = Object.keys(taskQueues);
            let maxLen = Math.max(...names.map(n => taskQueues[n].length));
            for (let i = 0; i < maxLen; i++) {
                names.forEach(name => {
                    if (taskQueues[name][i]) finalQueue.push(taskQueues[name][i]);
                });
            }
        } else {
            for (let name in taskQueues) finalQueue = finalQueue.concat(taskQueues[name]);
        }

        let schedule = [];
        let cursor = this.tm.getNextValidTime(startDate);

        finalQueue.forEach(item => {
            if (cursor >= endDate) return;
            let slotStart = new Date(cursor);
            let slotEnd = new Date(cursor);
            let needed = item.duration;
            let fits = false;

            while(!fits && slotStart < endDate) {
                let tempCursor = new Date(slotStart);
                let isInterrupted = false;
                for(let m=0; m<needed; m++) {
                    if(this.tm.isBlocked(tempCursor)) { isInterrupted = true; break; }
                    tempCursor.setMinutes(tempCursor.getMinutes() + 1);
                }
                if(!isInterrupted) { slotEnd = tempCursor; fits = true; } 
                else { slotStart = this.tm.getNextValidTime(tempCursor); }
            }

            if (fits && slotEnd <= endDate) {
                schedule.push({
                    title: item.title,
                    type: item.type,
                    start: new Date(slotStart),
                    end: new Date(slotEnd),
                    description: item.desc,
                    customNote: ''
                });
                cursor = new Date(slotEnd);
                cursor.setMinutes(cursor.getMinutes() + CONFIG.bufferMinutes);
                cursor = this.tm.getNextValidTime(cursor);
            }
        });
        return schedule;
    }
}

/* ================= ICS GENERATOR ================= */
class ICSGenerator {
    static generate(events) {
        let c = "BEGIN:VCALENDAR\r\nVERSION:2.0\r\nPRODID:-//CoderLo//LeitnerSched//EN\r\n";
        events.forEach(e => {
            // Combine system desc and custom note
            let finalDesc = e.description;
            if (e.customNote && e.customNote.trim() !== "") {
                finalDesc += ` \\n------------------\\nNOTE: ${e.customNote}`;
            }

            c += "BEGIN:VEVENT\r\n";
            c += `DTSTART:${this.fmt(e.start)}\r\nDTEND:${this.fmt(e.end)}\r\n`;
            c += `SUMMARY:${e.type === 'REVIEW' ? 'ðŸ”„ ' : 'âš¡ '}${e.title}\r\n`;
            c += `DESCRIPTION:${finalDesc}\r\n`;
            c += "END:VEVENT\r\n";
        });
        c += "END:VCALENDAR";
        return c;
    }
    static fmt(d) {
        const p = n => n < 10 ? '0' + n : n;
        return d.getFullYear()+p(d.getMonth()+1)+p(d.getDate())+'T'+p(d.getHours())+p(d.getMinutes())+'00';
    }
}

/* ================= UI CONTROLLER ================= */
const UI = {
    init() {
        const now = new Date();
        const nextW = new Date(now); nextW.setDate(nextW.getDate() + 5);
        document.getElementById('globalStart').value = now.toISOString().slice(0, 16);
        document.getElementById('globalEnd').value = nextW.toISOString().slice(0, 16);
        this.addTaskRow("Learn React Hooks", 20);
        this.addTaskRow("System Design", 10);
    },

    addTaskRow(n="", w="") {
        const d = document.createElement('div'); d.className = 'task-item';
        d.innerHTML = `<input type="text" class="t-name" value="${n}" placeholder="Task Name">
                       <input type="number" class="t-weight" value="${w}" placeholder="W">
                       <button class="delete-btn" onclick="this.parentElement.remove()" style="background:#ce4646;color:white;border:none">x</button>`;
        document.getElementById('taskList').appendChild(d);
    },

    getTasks() {
        return Array.from(document.querySelectorAll('.task-item')).map(r => ({
            name: r.querySelector('.t-name').value,
            weight: parseInt(r.querySelector('.t-weight').value || 1)
        })).filter(t => t.name);
    },

    toggleDescInput(idx) {
        const wrapper = document.getElementById(`desc-wrapper-${idx}`);
        const input = document.getElementById(`desc-input-${idx}`);
        if (wrapper.style.display === 'block') {
            wrapper.style.display = 'none';
        } else {
            wrapper.style.display = 'block';
            input.focus();
        }
    },

    log(evt, idx) {
        const consoleDiv = document.getElementById('previewConsole');
        
        const timeStr = `${evt.start.getDate()}/${evt.start.getMonth()+1} [${evt.start.getHours()}:${(evt.start.getMinutes()<10?'0':'')+evt.start.getMinutes()}]`;
        const typeClass = evt.type === 'WORK' ? 'type-work' : 'type-review';
        
        const wrapper = document.createElement('div');
        wrapper.className = 'log-container';

        // Main info row
        wrapper.innerHTML = `
            <div class="log-row">
                <div class="col-time">${timeStr}</div>
                <div class="col-type ${typeClass}">${evt.type}</div>
                <div class="col-msg">${evt.title}</div>
                <button class="btn-edit-desc" onclick="UI.toggleDescInput(${idx})">[âœŽ Note]</button>
            </div>
            <div class="desc-input-wrapper" id="desc-wrapper-${idx}">
                <input type="text" class="desc-input" id="desc-input-${idx}" 
                    placeholder="> Enter custom description here (optional)..." 
                    oninput="App.updateEventDesc(${idx}, this.value)"
                    value="${evt.customNote || ''}">
            </div>
        `;
        
        consoleDiv.appendChild(wrapper);
    }
};

/* ================= APP MAIN ================= */
const App = {
    events: [],
    
    generate() {
        const con = document.getElementById('previewConsole');
        con.innerHTML = ''; 
        
        const tasks = UI.getTasks();
        const start = document.getElementById('globalStart').value;
        const end = document.getElementById('globalEnd').value;
        const opts = {
            chunkSize: parseInt(document.getElementById('chunkSize').value),
            reviewSize: parseInt(document.getElementById('reviewSize').value),
            interleaving: document.getElementById('useInterleaving').checked,
            leitner: document.getElementById('useLeitner').checked
        };

        try {
            const scheduler = new SmartScheduler();
            this.events = scheduler.process(tasks, start, end, opts);

            const d = document.createElement('div');
            d.style.color = '#888'; d.style.borderBottom = '1px solid #333'; d.style.marginBottom='10px';
            d.innerText = `// Generated ${this.events.length} blocks. Config: Interleaving=${opts.interleaving}, Leitner=${opts.leitner}`;
            con.appendChild(d);

            // Pass index to UI.log to bind inputs
            this.events.forEach((evt, idx) => UI.log(evt, idx));
            
        } catch(e) {
            con.innerText = `[ERROR] ${e.message}`;
        }
    },

    updateEventDesc(idx, val) {
        if(this.events[idx]) {
            this.events[idx].customNote = val;
        }
    },

    downloadICS() {
        if(!this.events.length) return alert("Generate first!");
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([ICSGenerator.generate(this.events)], {type:'text/calendar'}));
        a.download = 'smart_schedule.ics';
        a.click();
    }
};

UI.init();
</script>
</body>
</html>
